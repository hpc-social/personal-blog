<!DOCTYPE html>
<html lang="en-US" data-theme="light">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0,viewport-fit=cover">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <title>Storage Utilization in the Long Tail of Science - hpc.social - Aggregated Personal Blog</title>
        <meta name="description" content="Shared personal experiences and stories">
        <meta name="keywords" content="">
        <base href="https://hpc.social/personal-blog" />
        
        <meta content="2014-11-05T15:53:00-07:00" property="article:published_time">
        <meta content="https://hpc.social/about/" property="article:author">
          
        <meta property="og:site_name" content="hpc.social - Aggregated Personal Blog">
        <meta property="og:type" content="article" />
        <meta property="og:url" content="https://hpc.social/personal-blog/2014/storage-utilization-in-the-long-tail-of-science/"/>
        <meta property="og:title" content="Storage Utilization in the Long Tail of Science - hpc.social - Aggregated Personal Blog" />
        <meta property="og:description" content="Shared personal experiences and stories" />
        <meta property="og:image" content="https://hpc.social/personal-blog/assets/images/hpc-social-blue.png"/>
        <meta name="twitter:site" content="@hpc_social" />
        <meta name="twitter:creator" content="@hpc_social" /> 
        <meta name="twitter:card" content="summary"/>
        <meta property="twitter:title" content="Storage Utilization in the Long Tail of Science - hpc.social - Aggregated Personal Blog" />
        <meta property="twitter:description" content="Shared personal experiences and stories" />
        <meta property="twitter:image" content="https://hpc.social/personal-blog/assets/images/hpc-social-blue.png" />
        <link rel="stylesheet" href="/personal-blog/assets/css/highlight.css">

        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link href="https://fonts.googleapis.com/css2?family=Catamaran:wght@300&display=swap" rel="stylesheet"> 

        <link rel="stylesheet" href="/personal-blog/assets/css/style.css">
        <link rel="shortcut icon" href="/personal-blog/assets/images/hpc-social-blue.png" />
        <link rel="alternate" type="application/atom+xml" title="hpc.social - Aggregated Personal Blog" href="https://hpc.social/personal-blog/atom.xml">
        <link rel="alternate" type="application/json" title="hpc.social - Aggregated Personal Blog" href="https://hpc.social/personal-blog/feed.json" />
        <link rel="sitemap" type="application/xml" title="sitemap" href="https://hpc.social/personal-blog/sitemap.xml" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"WebSite","author":{"@type":"Person","name":"hpc.social"},"description":"Shared personal experiences and stories","headline":"hpc.social - Aggregated Personal Blog","publisher":{"@type":"Organization","logo":{"@type":"ImageObject","url":"https://hpc.social/personal-blog/assets/images/hpc-social-blue.png"},"name":"hpc.social"},"sameAs":["https://twitter.com/","https://github.com/"],"url":"https://hpc.social/personal-blog"}</script>
    </head>
<body>

<div class="container">
	<div class="profile">
		<a href="https://hpc.social/personal-blog/"><img src="/personal-blog/assets/images/hpc-social-blue.png" class="profile-image"></a>
		<div class="profile-about">
			<h2 style="margin-bottom: 0; font-weight: 700;">hpc.social</h2>
			
			
				<a href="https://twitter.com/hpc_social" target="_blank"><img src="/personal-blog/assets/images/icon/twitter.svg" class="social-icon"></a>
			
			
			
			
				<a href="https://github.com/hpc-social" target="_blank"><img src="/personal-blog/assets/images/icon/github.svg" class="social-icon"></a>
			
			
			<a href="/personal-blog/about/"><img src="/personal-blog/assets/images/icon/me.svg" class="social-icon"></a>
			<br>
			High Performance Computing <br> Practitioners <br> and friends /#hpc
			<br>
			<div class="mode" id="mode-switcher" onclick="toggleNightMode();">
				<span></span>
			</div>
		</div>
	</div>
	
<div class="post-header">
	<div class="post-date">05.11.2014  &middot; <span class="reading-time" title="Estimated read time">
  
   28 mins  read </span>
</div>
	<div class="post-share">
		Share:&nbsp; 
		<a href="https://twitter.com/intent/tweet?source=tweetbutton&amp;original_referer=https://hpc.social/storage-utilization-in-the-long-tail-of-science&amp;text=Storage Utilization in the Long Tail of Science - https://hpc.social/storage-utilization-in-the-long-tail-of-science" target="_blank"><img src="https://hpc.social/personal-blog/assets/images/icon/twitter.svg" class="social-icon"></a>
	</div>
</div>

<div class="tags-container" style="padding:10px; font-size:18px; font-style:italic">
        This is a crosspost from &nbsp; <a target="_blank" href="https://glennklockwood.blogspot.com/search/label/hpc">Glenn K. Lockwood</a>&nbsp;Personal thoughts and opinions of a supercomputing enthusiast.&nbsp;See the original post&nbsp;<a target="_blank" href="https://glennklockwood.blogspot.com/2014/11/storage-utilization-in-long-tail-of.html">here</a>.</div>

<div class="blog-post-content">
	<h1>Storage Utilization in the Long Tail of Science</h1>
	<h2>Introduction</h2>
<p>Since changing careers and moving up to the San Francisco Bay Area in July, I haven’t had nearly as much time to post interesting things here on my blog—I guess that’s the startup life.  That isn’t to say that my life in DNA sequencing hasn’t been without interesting observations to explore though; the world of high-throughput sequencing is becoming increasingly dependent on high-performance computing, and many of the problems being solved in genomics and bioinformatics are stressing aspects of system architecture and cyberinfrastructure that haven’t gotten a tremendous amount of exercise from the more traditional scientific domains in computational research. <br /><br />Take, for example, <a href="http://systems.illumina.com/systems/hiseq-x-sequencing-system.ilmn">the biggest and baddest DNA sequencer on the market</a>: over the course of a three-day run, it outputs around 670 GB of raw (but compressed) sequence data, and this data is spread out over 1,400,000 files.  This would translate to an average file size of around 500 KB, but the reality is that the file sizes are a lot less uniform:<br /><br />&lt;table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td style="text-align: center;"&gt;<a href="http://3.bp.blogspot.com/-f1nf0-PQkRA/VCjZ9NZatZI/AAAAAAAAKuQ/cQZfm6HKV28/s1600/hiseqx-filesizedist.png" style="margin-left: auto; margin-right: auto;"><img border="0" height="271" src="http://3.bp.blogspot.com/-f1nf0-PQkRA/VCjZ9NZatZI/AAAAAAAAKuQ/cQZfm6HKV28/s1600/hiseqx-filesizedist.png" width="400" /></a>&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td class="tr-caption" style="text-align: center;"&gt;Figure 1. File size distribution of a single flow cell output (~770 gigabases) on Illumina’s highest-end sequencing platform&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;<br />After some basic processing (which involves opening and closing hundreds of these files repeatedly and concurrently), these data files are converted into very large files (tens or hundreds of gigabytes each) which then get reduced down to data that is more digestible over the course of hundreds of CPU hours.  As one might imagine, this entire process is very good at taxing many aspects of file systems, and on the computational side, most of this IO-intensive processing is not distributed and performance benefits most from single-stream, single-client throughput.<br /><br />As a result of these data access and processing patterns, the storage landscape in the world of DNA sequencing and bioinformatics is quite different from conventional supercomputing.  Some large sequencing centers do use the file systems we know and love (and hate) like <a href="http://www.nersc.gov/users/computational-systems/genepool/file-storage-and-io/">GPFS at JGI</a> and <a href="http://insidehpc.com/2013/10/sanger-institute-deploys-22-petabytes-lustre-powered-ddn-storage/">Lustre at Sanger</a>, but it appears that most small- and mid-scale sequencing operations are relying heavily on network-attached storage (NAS) for both receiving raw sequencer data and being a storage substrate for all of the downstream data processing.<br /><br />I say all of this because these data patterns—accessing large quantities of small files and large files with a high degree of random IO—is a common trait in many scientific applications used in the “long tail of science.”  The fact is, the sorts of IO for which parallel file systems like Lustre and GPFS are designed are tedious (if not difficult) to program, and for the majority of codes that don’t require thousands of cores to make new discoveries, simply reading and writing data files in a naïve way is “good enough.”<br /><br />&lt;h3&gt;The Long Tail&lt;/h3&gt;This long tail of science is also using up a huge amount of the supercomputing resources made available to the national open science community; to illustrate, 98% of all jobs submitted to the XSEDE supercomputers in 2013 used 1024 or fewer CPU cores, and these modest-scale jobs represented over 50% of all the CPU time burned up on these machines.<br /><br />&lt;table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td style="text-align: center;"&gt;<a href="http://3.bp.blogspot.com/-h1Xc98JyrW0/VCjapVMZXQI/AAAAAAAAKuY/aB-B7ZjkOZQ/s1600/Job%2BSize%2BDistribution%2B-%2B2013.png" style="margin-left: auto; margin-right: auto;"><img border="0" height="271" src="http://3.bp.blogspot.com/-h1Xc98JyrW0/VCjapVMZXQI/AAAAAAAAKuY/aB-B7ZjkOZQ/s1600/Job%2BSize%2BDistribution%2B-%2B2013.png" width="400" /></a>&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td class="tr-caption" style="text-align: center;"&gt;Figure 2. Cumulative job size distribution (weighted by job count and SUs consumed) for all jobs submitted to XSEDE compute resources in 2013&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;<br />The NSF has responded to this shift in user demand by awarding <a href="http://www.sdsc.edu/News%20Items/PR100313_comet.html">Comet, a 2 PF supercomputer designed to run these modest-scale jobs</a>.  The Comet architecture limits its full-bisection bandwidth interconnectivity to <a href="http://dx.doi.org/10.1145/2616498.2616540">groups of 72 nodes</a>, and these 72-node islands will actually have enough cores to satisfy 99% of all the jobs submitted to XSEDE clusters in 2013 (see above).  By limiting the full-bisection connectivity to smaller islands and using less rich connectivity between islands, the cost savings in not having to buy so many mid-tier and core switches are then turned into additional CPU capacity.<br /><br />What the Comet architecture <i>doesn’t</i> address, however, is the question of data patterns and IO stress being generated by this same long tail of science—the so-called 99%.  If DNA sequencing is any indicator of the 99%, parallel file systems are actually a poor choice for high-capacity, mid-scale jobs because their <a href="http://dx.doi.org/10.1145/2159352.2159356">performance degrades significantly when facing many small files</a>.  Now, the real question is, are the 99% of HPC jobs really generating and manipulating lots of small files in favor of the large striped files that Lustre and GPFS are designed to handle?  That is, might the majority of jobs on today’s HPC clusters actually be better served by file systems that are less scalable but handle small files and random IO more gracefully?<br /><br />Some colleagues and I set out to answer this question last spring, and a part of this quest involved looking at every single file on two of SDSC’s Data Oasis file systems.  This represented about 1.7 PB of real user data spread across two Lustre 2.4 file systems—one designed for temporary scratch data and the other for projects storage—and we wanted to know if users’ data really consisted of the large files that Lustre loves or if, like job size, the 99% are really working with small files.  Since SDSC’s two national resources, Gordon and Trestles, restrict the maximum core count for user jobs to modest-scale submissions, these file systems should contain files representative of long-tail users.<br /><br />&lt;h2&gt;Scratch File Systems&lt;/h2&gt;At the roughest cut, files can be categorized based on whether their size is on the order of bytes and kilobytes (size &lt; 1024*1024 bytes), megabytes (&lt; 1024 KB), gigabytes (&lt;1024 MB), and terabytes (&lt; 1024 GB).  Although pie charts are generally a terrible way to show relative compositions, this is how the files on the 1.2 PB scratch file system broke down:<br /><br />&lt;table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td style="text-align: center;"&gt;<a href="http://1.bp.blogspot.com/-e-UpylKZPBw/VCjcZFRbClI/AAAAAAAAKuk/uf38vgGNnNk/s1600/file%2Bcount%2Bpie.png" style="margin-left: auto; margin-right: auto;"><img border="0" height="320" src="http://1.bp.blogspot.com/-e-UpylKZPBw/VCjcZFRbClI/AAAAAAAAKuk/uf38vgGNnNk/s1600/file%2Bcount%2Bpie.png" width="296" /></a>&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td class="tr-caption" style="text-align: center;"&gt;Figure 3. Fraction of file count consumed by files of a given size on Data Oasis’s scratch file system for Gordon&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;<br /><br />The above figure shows the number of files on the file system classified by their size, and there are clearly a preponderance of small files less than a gigabyte in size.  This is not terribly surprising as the data is biased towards smaller files; that is, you can fit a thousand one-megabyte files in the same space that a single one-gigabyte file would take up.  Another way to show this data is by how much file system capacity is taken up by files of each size:<br /><br />&lt;table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td style="text-align: center;"&gt;<a href="http://3.bp.blogspot.com/-htbZijzc2MY/VCjcdu-hPrI/AAAAAAAAKus/Y8F4ohme4Yg/s1600/file%2Bsize%2Bpie.png" style="margin-left: auto; margin-right: auto;"><img border="0" height="320" src="http://3.bp.blogspot.com/-htbZijzc2MY/VCjcdu-hPrI/AAAAAAAAKus/Y8F4ohme4Yg/s1600/file%2Bsize%2Bpie.png" width="296" /></a>&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td class="tr-caption" style="text-align: center;"&gt;Figure 4. File system capacity consumed by files of a given size on Data Oasis’s scratch file system for Gordon&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;<br /><br />This makes it very apparent that the vast majority of the used space on this scratch file system—a total of 1.23 PB of data—are taken up by files on the order of gigabytes and megabytes.  There were only seventeen files that were a terabyte or larger in size.  <br /><br />Incidentally, I don’t find it too surprising that there are so few terabyte-sized files; even in the realm of Hadoop, median job dataset sizes are on the order of a dozen gigabytes (e.g., Facebook has reported that <a href="http://dx.doi.org/10.1145/2169090.2169092">90% of its jobs read in under 100 GB of data</a>).  Examining file sizes with much finer granularity reveals that the research data on this file system isn’t even of Facebook scale though:<br /><br />&lt;table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td style="text-align: center;"&gt;<a href="http://4.bp.blogspot.com/-FrkhmvkuOao/VCjclW_IAqI/AAAAAAAAKu0/7sMuQQlrXas/s1600/file%2Bsize%2Bdistribution.png" style="margin-left: auto; margin-right: auto;"><img border="0" height="272" src="http://4.bp.blogspot.com/-FrkhmvkuOao/VCjclW_IAqI/AAAAAAAAKu0/7sMuQQlrXas/s1600/file%2Bsize%2Bdistribution.png" width="400" /></a>&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td class="tr-caption" style="text-align: center;"&gt;Figure 5. Number of files of a given size on Data Oasis’s scratch file system for Gordon.  This data forms the basis for Figure 3 above&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;<br /><br />While there are a large number of files on the order of a few gigabytes, it seems that files on the order of tens of gigabytes or larger are far more scarce.  Turning this into relative terms,<br /><br />&lt;table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td style="text-align: center;"&gt;<a href="http://1.bp.blogspot.com/-b1zxYPEkiA4/VCjctOul9LI/AAAAAAAAKu8/I0LHbxoEoTU/s1600/cumul%2Bfile%2Bsize%2Bdistribution.png" style="margin-left: auto; margin-right: auto;"><img border="0" height="276" src="http://1.bp.blogspot.com/-b1zxYPEkiA4/VCjctOul9LI/AAAAAAAAKu8/I0LHbxoEoTU/s1600/cumul%2Bfile%2Bsize%2Bdistribution.png" width="400" /></a>&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td class="tr-caption" style="text-align: center;"&gt;Figure 6. Cumulative distribution of files of a given size on Data Oasis’s scratch file system for Gordon&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;<br /><br />we can make more meaningful statements.  In particular,<br /><br />&lt;ul&gt;&lt;li&gt;90% of the files on this Lustre file system are 1 megabyte or smaller&lt;/li&gt;&lt;li&gt;99% of files are 32 MB or less&lt;/li&gt;&lt;li&gt;99.9% of files are 512 MB or less&lt;/li&gt;&lt;li&gt;and 99.99% of files are 4 GB or less&lt;/li&gt;&lt;/ul&gt;<br />The first statement is quite powerful when you consider the fact that the default stripe size in Lustre is 1 MB.  The fact that 90% of files on the file system are smaller than this means that <b>90% of users’ files really gain no advantages by living on Lustre</b>.  Furthermore, since this is a scratch file system that is meant to hold temporary files, it would appear that either user applications are generating a large amount of small files, or users are copying in large quantities of small files and improperly using it for cold storage.  Given the quota policies for Data Oasis, I suspect there is a bit of truth to both.<br /><br />Circling back a bit though, I said earlier that comparing just the quantity of files can be a bit misleading since a thousand 1 KB files will take up the same space as a single 1 MB file.   We can also look at how much total space is taken up by files of various sizes.<br /><br />&lt;table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td style="text-align: center;"&gt;<a href="http://3.bp.blogspot.com/-jSmVlIJTa9E/VCjdrFMZlZI/AAAAAAAAKvI/gVPZm53WnDA/s1600/bin%2Bweight%2Band%2Bcumul%2Bdist.png" style="margin-left: auto; margin-right: auto;"><img border="0" height="271" src="http://3.bp.blogspot.com/-jSmVlIJTa9E/VCjdrFMZlZI/AAAAAAAAKvI/gVPZm53WnDA/s1600/bin%2Bweight%2Band%2Bcumul%2Bdist.png" width="400" /></a>&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td class="tr-caption" style="text-align: center;"&gt;Figure 7. File system capacity consumed by files of a given size on Data Oasis’s scratch file system for Gordon.  This is just a more finely diced version of the data presented in Figure 4 above.&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;<br />The above chart is a bit data-dense so it takes some staring at to understand what’s going on.  First looking at the purple line, we can pull out some pretty interesting facts:<br /><br />&lt;ul&gt;&lt;li&gt;Half of the file system’s used capacity (50%) is consumed by files that are 1 GB or less in size&lt;/li&gt;&lt;li&gt;Over 20% of the file system’s used capacity is taken up by files smaller than 64 MB&lt;/li&gt;&lt;li&gt;About 10% of the capacity is used by files that are 64 GB or larger&lt;/li&gt;&lt;/ul&gt;<br />The blue boxes represent the derivative of that purple line—that is, how much space is taken up by files of only one specific size.  The biggest chunk of the file system (141 TB) is taken up by 4 GB files, but it appears that there is a substantial range of file sizes that take up very similarly sized pieces of the pie.  512 MB files take up a total of 139 TB; 1 GB, 2 GB, and 8 GB files all take up over 100 TB of total space each as well.  In fact, files ranging from 512 MB to 8 GB comprise 50% of the total file system capacity.<br /><br />Why the sweet spot for space-consuming files is between 512 MB and 8 GB is unclear, but I suspect it’s more caused by the human element in research.  In my own research, I worked with files in this range simply because it was enough data to be statistically meaningful while still small enough to quickly re-analyze or transfer to a colleague.  For file sizes above this range, the mass of the data made it difficult to manipulate using the “long-tail” cyberinfrastructure available to me. But, perhaps as more national-scale systems comes online to meet the needs of these sorts of workloads, this sweet spot will creep out to larger file sizes.<br /><br />&lt;h2&gt;Projects Storage&lt;/h2&gt;The above discussion admittedly comes with a lot of caveats.  In particular, the scratch file system we examined was governed by no hard quotas which did lead some people to leave data resident for longer than they probably should have.  However, the other file system we analyzed was SDSC’s Data Oasis projects storage which was architected for capacity over performance and featured substantially more disks per OSS.  This projects storage also came with 500 GB quotas by default, forcing users to be a little more mindful of what was worth keeping.<br /><br />Stepping back to the coarse-grained kilobyte/megabyte/gigabyte/terabyte pie charts, here is how projects storage utilization compared to scratch storage:<br /><br />&lt;table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td style="text-align: center;"&gt;<a href="http://3.bp.blogspot.com/-wdsd5yB18VE/VCjiRbSA0HI/AAAAAAAAKvU/W52Xv6-Z8-w/s1600/ct%2Bbreakdown%2Bcompare.png" style="margin-left: auto; margin-right: auto;"><img border="0" height="400" src="http://3.bp.blogspot.com/-wdsd5yB18VE/VCjiRbSA0HI/AAAAAAAAKvU/W52Xv6-Z8-w/s1600/ct%2Bbreakdown%2Bcompare.png" width="348" /></a>&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td class="tr-caption" style="text-align: center;"&gt;Figure 8. Fraction of file count consumed by files of a given size on Data Oasis’s projects file system (shared between Gordon and Trestles users)&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;<br />On the basis of file counts, it’s a bit surprising that users seem to store more smaller (kilobyte-sized) files in their projects space than their scratch space.  This may imply that the beginning and end data bookending simulations aren’t as large as the intermediate data generated during the calculation.  Alternately, it may be a reflection of user naïveté; I’ve found that newer users were often afraid to use the scratch space because of the perception that their data may vanish from there without advanced notice.  Either way, gigabyte-sized files comprised a few hundredths of a percent of files, and terabyte-sized files were more scarce still on both file systems.  The trend was uniformly towards smaller sizes on projects space.<br /><br />As far as space consumed by these files, the differences remain subtle.<br /><br />&lt;table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td style="text-align: center;"&gt;<a href="http://1.bp.blogspot.com/-3cs8iwXSnRA/VCjmML1IMMI/AAAAAAAAKvg/HUFZh8BYsLk/s1600/size%2Bbkdown%2Bcompare.png" style="margin-left: auto; margin-right: auto;"><img border="0" height="271" src="http://1.bp.blogspot.com/-3cs8iwXSnRA/VCjmML1IMMI/AAAAAAAAKvg/HUFZh8BYsLk/s1600/size%2Bbkdown%2Bcompare.png" width="400" /></a>&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td class="tr-caption" style="text-align: center;"&gt;Figure 9. Fraction of file system capacity consumed by files of a given size on Data Oasis’s projects file system&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;<br />There appears to be a trend towards users keeping larger files in their projects space, and the biggest change is the decrease in megabyte-sized files in favor of gigabyte-sized files.  However, this trend is very small and persists across a finer-grained examination of file size distributions:<br /><br />&lt;div class="separator" style="clear: both; text-align: center;"&gt;&lt;/div&gt;</p>
<table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><a href="http://3.bp.blogspot.com/-yYPXPGFN2ck/VCjvIHxoJpI/AAAAAAAAKv8/MiUafRm7yCU/s1600/megaplot.png" style="margin-left: auto; margin-right: auto;"><img border="0" height="271" src="http://3.bp.blogspot.com/-yYPXPGFN2ck/VCjvIHxoJpI/AAAAAAAAKv8/MiUafRm7yCU/s1600/megaplot.png" width="400" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Figure 10.&nbsp;File system capacity consumed by files of a given size on Data Oasis's projects file system</td></tr></tbody></table>
<p><br />Half of the above plot is the same data shown above, making this plot twice as busy and confusing.  However there’s a lot of interesting data captured in it, so it’s worth the confusing presentation.  In particular, the overall distribution of mass with respect to the various file sizes is remarkably consistent between scratch and projects storage.  We see the same general peak of file size preference in the 1 GB to 10 GB range, but there is a subtle bimodal divide in projects storage that reveals preference for 128MB-512MB and 4GB-8GB files which manifests in the integrals (red and purple lines) that show a visibly greater slope in these regions.<br /><br />The observant reader will also notice that the absolute values of the bars are smaller for projects storage and scratch storage; this is a result of the fact that the projects file system is subject to quotas and, as a result, is not nearly as full of user data.  To complicate things further, the projects storage represents user data from two different machines (each with unique job size policies, to boot), whereas the scratch storage is only accessible from one of those machines.  Despite these differences though, user data follows very similar distributions between both file systems.<br /><br />&lt;h2&gt;Corollaries&lt;/h2&gt;It is probably unclear what to take away from these data, and that is with good reason.  There are fundamentally two aspects to quantifying storage utilizations–raw capacity and file count–because they represent two logically separate things.  There is some degree of interchangeability (e.g., storing a whole genome in one file vs. storing each chromosome its own file), and this is likely contributing to the broad peak in file size between 512 MB and 8 GB.  With that being said, it appears that the typical long-tail user stores a substantial amount of decidedly “small” files on Lustre, and this is exemplified by the fact that 90% of the files resident on the file systems analyzed here are 1 MB or less in size.<br />&lt;div&gt;<br />&lt;/div&gt;</p>
<div>This alone suggests that large parallel file systems may not actually be the most appropriate choice for HPC systems that are designed to support a large group of long-tail users. &nbsp;While file systems like Lustre and GPFS certainly provide a unique <i>capability</i> in that some types of medium-sized jobs absolutely require the IO capabilities of parallel file systems, there are a larger number of long-tail applications that do single-thread IO, and some of these perform IO in such an abusive way (looking at you, quantum chemistry) that they cannot run on file systems like Lustre or GPFS because of the number of small files and random IO they use.</div>
<div><br /></div>
<div>So if Lustre and GPFS aren't the unequivocal best choice for storage in long-tail HPC, what are the other options?</div>
<div><br /><h3>Burst Buffers</h3></div>
<div>I would be remiss if I neglected to mention burst buffers here since they are designed, in part, to address the limitations of parallel file systems. &nbsp;However, their actual usability remains unproven. &nbsp;Anecdotally, long-tail users are generally not quick to alter the way they design their jobs to use cutting-edge technology, and my personal experiences with Gordon (and its 300 TB of flash) were that getting IO-nasty user applications to effectively utilize the flash was often a very manual process that introduced new complexities, pitfalls, and failure modes. &nbsp;Gordon was a very experimental platform though, and <a href="http://www.cray.com/Products/Computing/XC/DataWarp.aspx">Cray's new DataWarp</a> burst buffer seems to be the first large-scale productization of this idea. &nbsp;It will be interesting to see how well it works for real users when the technology starts <a href="https://www.nersc.gov/users/computational-systems/cori/">hitting the floor for open science in mid-2016</a>, if not sooner.</div>
<div><h3>High-Performance NAS</h3></div>
<div>An emerging trend in HPC storage is the use of high-performance NAS as a complementary file system technology in HPC platforms. &nbsp;Traditionally, NAS has been a very poor choice for HPC applications because of the limited scalability of the typical NAS architecture--data resides on traditional local file system with network service being provided by an additional software layer like NFS, and the ratio of storage capacity to network bandwidth out of the NAS is very high.</div>
<div><br /></div>
<div>The emergence of cheap RAM and enterprise SSDs has allowed some sophisticated file systems like ZFS and NetApp's WAFL to demonstrate very high performance, especially in delivering very high random read performance, by using both RAM and flash as a buffer between the network and spinning rust. &nbsp;This allows certain smaller-scale jobs to enjoy substantially better performance when running on flash-backed NAS than a parallel file system. &nbsp;Consider the following IOP/metadata benchmark run on a parallel file system and a NAS head with SSDs for caching:<br /><br /><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><a href="http://1.bp.blogspot.com/-fyF1j9G0ouU/VFHNnHOB-YI/AAAAAAAAKxQ/owVhLiILb1E/s1600/mdstat-stats-per-sec.png" style="margin-left: auto; margin-right: auto;"><img border="0" height="271" src="http://1.bp.blogspot.com/-fyF1j9G0ouU/VFHNnHOB-YI/AAAAAAAAKxQ/owVhLiILb1E/s1600/mdstat-stats-per-sec.png" width="400" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Figure 11. File stat rate on flash-backed NAS vs. a parallel file system as measured by <a href="http://mdtest.sourceforge.net/">the mdtest benchmark</a></td></tr></tbody></table><br />A four-node job that relies on <a href="http://pubs.opengroup.org/onlinepubs/009695399/functions/stat.html">statting</a> many small files (for example, an application that traverses a large directory structure such as the output of one of the Illumina sequencers I mentioned above) <i>can</i> achieve a much higher IO rate on a high-performance NAS than on a parallel file system. &nbsp;Granted, there are a lot of qualifications to be made with this statement and benchmarking high-performance NAS is worth a post of its own, but the above data illustrate a case where NAS may be preferable over something like Lustre.</div>
<h3>Greater Context</h3>
<div>Parallel file systems like Lustre and GPFS will always play an essential role in HPC, and I don't want to make it sound like they can be universally replaced by high-performance NAS. &nbsp;They are fundamentally architected to scale out so that increasing file system bandwidth does not require adding new partitions or using <a href="http://www.netapp.com/us/products/platform-os/infinite-volume.aspx">software to emulate a single namespace</a>. &nbsp;In fact, the single namespace of parallel file systems makes the management of the storage system, its users, and the underlying resources very flexible and straightforward. &nbsp;No volume partitioning needs to be imposed, so scientific applications' and projects' data consumption do not have to align with physical hardware boundaries.<br /><br /><div>However, there are cases where a single namespace is not necessary at all; for example, user home directories are naturally partitioned with fine granularity and can be mounted in a uniform location while physically residing on different NAS heads with a simple autofs map. &nbsp;In this example, leaving user home directories on a pool of NAS filers offers two big benefits:<br /><br /><ol><li>Full independence of the underlying storage mitigates the impact of one bad user. &nbsp;A large job dropping multiple files per MPI process will crush both Lustre and NFS, but in the case of Lustre, the MDS may become unresponsive and block IO across all users' home directories.</li><li>Flash caches on NAS can provide higher performance on IOP-intensive workloads at long-tail job sizes. &nbsp;In many ways, high-performance NAS systems have the built-in burst buffers that parallel file systems are only now beginning to incorporate.</li></ol><div>Of course, these two wins come at a cost:</div>
<div><ol><li>Fully decentralized storage is more difficult to manage. &nbsp;For example, balancing capacity across all NAS systems is tricky when users have very different data generation rates that they do not disclose ahead of time.</li><li>Flash caches can only get you so far, and NFS will fall over when enough IO is thrown at it. &nbsp;I mentioned that 98% of all jobs use 1024 cores or fewer (see Figure 1), but 1024 cores all performing heavy IO on a typical capacity-rich, bandwidth-poor NAS head will cause it to grind to a halt.</li></ol><div><div>Flash-backed high-performance NAS is not an end-all storage solution for long-tail computational science, but it also isn't something to be overlooked outright. &nbsp;As with any technology in the HPC arena, its utility may or may not match up well with users' workloads, but when it does, it can deliver less pain and better performance than parallel file systems.</div>
</div>
</div>
<div><br /><h2>Acknowledgments&nbsp;</h2></div>
</div>
</div>
<div>As I mentioned above, the data I presented here was largely generated as a result of an internal project in which I participated while at SDSC. &nbsp;I couldn't have cobbled this all together without the help of SDSC's HPC Systems group, and I'm really indebted to <a class="g-profile" href="https://plus.google.com/115709389472600856394" target="_blank">+Rick</a>,&nbsp;<a class="g-profile" href="https://plus.google.com/105132496853043288048" target="_blank">+Haisong</a>, and&nbsp;<a class="g-profile" href="https://plus.google.com/113299603442523075439" target="_blank">+Trevor</a>&nbsp;for doing a lot of the heavy lifting in terms of generating the original data, getting systems configured to test, and figuring out what it all meant when the dust settled (even after I had left!). &nbsp;SDSC's really a world-class group of individuals.</div>

</div>
<div class="tags-container">
	
</div>
<style>
#uppy {
  position: fixed;
  bottom: 50px;
  right: 50px;
  z-index: 99;
  border: none;
  outline: none;
  background-color: darkturquoise;
  color: black;
  cursor: pointer;
  margin:15px;
  border-radius: 10px;
  width: 100px;
  height: 20px;
}

#returnTop:hover {
  background-color: #555;
}
</style>

<button id="uppy" title="Return to Top" class="btn btn-lg">Back to top</button>

<script>
(function() {

var scrollTop = function() {
    window.scrollTo(0, 0);
};

document.getElementById('uppy').onclick = scrollTop;

})();
</script>


<div class="navigation">
	
		<a class="prev" href="/personal-blog/2014/the-shell-for-scientists/">< The Shell For Scientists</a>
	 
	<a class="next" href="/personal-blog/2014/machine-learning-for-scientists/">Machine Learning for Scientists ></a>

</div>

	<div class="footer">
		<span style="padding-right:10px"><font color="red">©️ </font><a href="https://hpc.social"><b>hpc.social</b> community</a></span> 
		| <a style="padding-left:10px; padding-right:10px" href="/personal-blog/archive/">Archive</a>
		| <a style="padding-left:10px; padding-right:10px" href="/personal-blog/">Posts</a>
		| <a style="padding-left:10px; padding-right:10px" href="/personal-blog/about/">About</a>
		| <a style="padding-left:10px; padding-right:10px" href="https://hpc.social/blog">hpc.social blogs</a>
		| <a style="padding-left:37%;" target="_blank" href="https://github.com/hpc-social/personal-blog">Add Your Blog</a>
	</div>
</div>
    <script src="/personal-blog/assets/scripts.js"></script>
    <script type="text/javascript">
        if (localStorage.theme === 'light') {
            document.documentElement.setAttribute('data-theme', 'light');
            document.getElementById('mode-switcher').classList.add('active');
        } else if (localStorage.theme === 'dark' || localStorage.theme === '' || (!('theme' in localStorage))) {
            document.documentElement.setAttribute('data-theme', 'dark');
            document.getElementById('mode-switcher').classList.add('active');
        }
    </script>
</body>
</html>

