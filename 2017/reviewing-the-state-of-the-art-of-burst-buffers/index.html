<!DOCTYPE html>
<html lang="en-US" data-theme="light">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0,viewport-fit=cover">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <title>Reviewing the state of the art of burst buffers - hpc.social - Aggregated Personal Blog</title>
        <meta name="description" content="Shared personal experiences and stories">
        <meta name="keywords" content="">
        <base href="https://hpc.social/personal-blog" />
        
        <meta content="2017-03-13T01:07:00-06:00" property="article:published_time">
        <meta content="https://hpc.social/about/" property="article:author">
          
        <meta property="og:site_name" content="hpc.social - Aggregated Personal Blog">
        <meta property="og:type" content="article" />
        <meta property="og:url" content="https://hpc.social/personal-blog/2017/reviewing-the-state-of-the-art-of-burst-buffers/"/>
        <meta property="og:title" content="Reviewing the state of the art of burst buffers - hpc.social - Aggregated Personal Blog" />
        <meta property="og:description" content="Shared personal experiences and stories" />
        <meta property="og:image" content="https://hpc.social/personal-blog/assets/images/hpc-social-blue.png"/>
        <meta name="twitter:site" content="@hpc_social" />
        <meta name="twitter:creator" content="@hpc_social" /> 
        <meta name="twitter:card" content="summary"/>
        <meta property="twitter:title" content="Reviewing the state of the art of burst buffers - hpc.social - Aggregated Personal Blog" />
        <meta property="twitter:description" content="Shared personal experiences and stories" />
        <meta property="twitter:image" content="https://hpc.social/personal-blog/assets/images/hpc-social-blue.png" />
        <link rel="stylesheet" href="/personal-blog/assets/css/highlight.css">

        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link href="https://fonts.googleapis.com/css2?family=Catamaran:wght@300&display=swap" rel="stylesheet"> 

        <link rel="stylesheet" href="/personal-blog/assets/css/style.css">
        <link rel="shortcut icon" href="/personal-blog/assets/images/hpc-social-blue.png" />
        <link rel="alternate" type="application/atom+xml" title="hpc.social - Aggregated Personal Blog" href="https://hpc.social/personal-blog/atom.xml">
        <link rel="alternate" type="application/json" title="hpc.social - Aggregated Personal Blog" href="https://hpc.social/personal-blog/feed.json" />
        <link rel="sitemap" type="application/xml" title="sitemap" href="https://hpc.social/personal-blog/sitemap.xml" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"WebSite","author":{"@type":"Person","name":"hpc.social"},"description":"Shared personal experiences and stories","headline":"hpc.social - Aggregated Personal Blog","publisher":{"@type":"Organization","logo":{"@type":"ImageObject","url":"https://hpc.social/personal-blog/assets/images/hpc-social-blue.png"},"name":"hpc.social"},"sameAs":["https://twitter.com/","https://github.com/"],"url":"https://hpc.social/personal-blog"}</script>
    </head>
<body>

<div class="container">
	<div class="profile">
		<a href="https://hpc.social/personal-blog/"><img src="/personal-blog/assets/images/hpc-social-blue.png" class="profile-image"></a>
		<div class="profile-about">
			<h2 style="margin-bottom: 0; font-weight: 700;">hpc.social</h2>
			
			
				<a href="https://twitter.com/hpc_social" target="_blank"><img src="/personal-blog/assets/images/icon/twitter.svg" class="social-icon"></a>
			
			
			
			
				<a href="https://github.com/hpc-social" target="_blank"><img src="/personal-blog/assets/images/icon/github.svg" class="social-icon"></a>
			
			
			<a href="/personal-blog/about/"><img src="/personal-blog/assets/images/icon/me.svg" class="social-icon"></a>
			<br>
			High Performance Computing <br> Practitioners <br> and friends /#hpc
			<br>
			<div class="mode" id="mode-switcher" onclick="toggleNightMode();">
				<span></span>
			</div>
		</div>
	</div>
	
<div class="post-header">
	<div class="post-date">13.03.2017  &middot; <span class="reading-time" title="Estimated read time">
  
   30 mins  read </span>
</div>
	<div class="post-share">
		Share:&nbsp; 
		<a href="https://twitter.com/intent/tweet?source=tweetbutton&amp;original_referer=https://hpc.social/reviewing-the-state-of-the-art-of-burst-buffers&amp;text=Reviewing the state of the art of burst buffers - https://hpc.social/reviewing-the-state-of-the-art-of-burst-buffers" target="_blank"><img src="https://hpc.social/personal-blog/assets/images/icon/twitter.svg" class="social-icon"></a>
	</div>
</div>

<div class="tags-container" style="padding:10px; font-size:18px; font-style:italic">
        This is a crosspost from &nbsp; <a target="_blank" href="https://glennklockwood.blogspot.com/search/label/hpc">Glenn K. Lockwood</a>&nbsp;Personal thoughts and opinions of a supercomputing enthusiast.&nbsp;See the original post&nbsp;<a target="_blank" href="https://glennklockwood.blogspot.com/2017/03/reviewing-state-of-art-of-burst-buffers.html">here</a>.</div>

<div class="blog-post-content">
	<h1>Reviewing the state of the art of burst buffers</h1>
	<!-- <div style="border-left: 3px solid #32aaff; border: 1px solid #32aaff; float: right; font-size: x-small; margin-left: 6px; padding: 6px; width: 250px;">If you're interested in burst buffers and happen to be a student, please reach out and contact me!  We have an <a href="https://lbl.taleo.net/careersection/2/jobdetail.ftl?job=83459">internship opportunity in performance analysis of our 1.8 PB/1.5 TB/sec burst buffer</a> for students of all levels of experience.</div>
 -->
<p>Just over two years ago I attended my first DOE workshop as a guest representative of the NSF supercomputing centers, and I wrote a post that summarized my key observations of how the DOE was approaching the increase in data-intensive computing problems.  At the time, the most significant thrusts seemed to be<br />&lt;ol&gt;&lt;li&gt;understanding scientific workflows to keep pace with the need to process data in complex ways&lt;/li&gt;&lt;li&gt;deploying burst buffers to overcome the performance limitations of spinning disk relative to the increasing scale of simulation data&lt;/li&gt;&lt;li&gt;developing methods and processes to curate scientific data&lt;/li&gt;&lt;/ol&gt;Here we are now two years later, and these issues still take center stage in the discussion surrounding the future of  data-intensive computing.  The DOE has made significant progress in defining its path forward in these areas though, and in particular, both the roles of burst buffers and scientific workflows have a much clearer focus on DOE’s HPC roadmap.  Burst buffers in particular are becoming a major area of interest since they are now becoming commercially available, so in the interests of updating some of the incorrect or incomplete thoughts I wrote about two years ago, I thought I’d write about the current state of the art in burst buffers in HPC.<br /><br />Two years ago I had observed that there were two major camps in burst buffer implementations: one that is more tightly integrated with the compute side of the platform that utilizes explicit allocation and use, and another that is more closely integrated with the storage subsystem and acts as a transparent I/O accelerator.  Shortly after I made that observation though, Oak Ridge and Lawrence Livermore announced their GPU-based leadership systems, Summit and Sierra, which would feature a new type of burst buffer design altogether that featured on-node nonvolatile memory.<br /><br />This CORAL announcement, combined with the deployment of production, large-scale burst buffers at <a href="http://www.nersc.gov/news-publications/nersc-news/nersc-center-news/2015/early-users-to-test-new-burst-buffer-on-cori/">NERSC</a>, <a href="http://permalink.lanl.gov/object/tr?what=info:lanl-repo/lareport/LA-UR-15-27819">Los Alamos</a>, and <a href="https://www.hpc.kaust.edu.sa/content/datawarp-burst-buffer-0">KAUST</a>, has led me to re-think my taxonomy of burst buffers.  Specifically, it really is important to divide burst buffers into their hardware architectures and software usage modes; different burst buffer architectures can provide the same usage modalities to users, and different modalities can be supported by the same architecture.<br />&lt;div&gt;<br />&lt;/div&gt;
For the sake of laying it all out, let’s walk through the taxonomy of <i>burst buffer hardware architectures</i> and <i>burst buffer software usage modalities</i>.<br /><br />&lt;h2&gt;Burst Buffer Hardware Architectures&lt;/h2&gt;First, consider your typical medium- or large-scale HPC system architecture <i>without</i> a burst buffer:<br /><br />&lt;div class="separator" style="clear: both; text-align: center;"&gt;<a href="https://4.bp.blogspot.com/-3ETIppfFZVU/WMWRxNCWvSI/AAAAAAAAo7Y/qXtIJNn2LvQf-oyMSA-t3m2zQ7M7MeAPgCLcB/s1600/architecture-baseline.png" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="162" src="https://4.bp.blogspot.com/-3ETIppfFZVU/WMWRxNCWvSI/AAAAAAAAo7Y/qXtIJNn2LvQf-oyMSA-t3m2zQ7M7MeAPgCLcB/s320/architecture-baseline.png" width="320" /></a>&lt;/div&gt;
<br />In this design, you have<br /><br />&lt;ul&gt;&lt;li&gt;<b>Compute Nodes (CN)</b>, which might be commodity whitebox nodes like the <a href="https://www.nextplatform.com/2015/06/24/hyperscale-systems-make-headway-into-hpc/">Dell C6320 nodes in SDSC’s Comet system</a> or Cray XC compute blades&lt;/li&gt;&lt;li&gt;<b>I/O Nodes (ION)</b>, which might be commodity Lustre LNET routers (commodity clusters), <a href="http://docs.cray.com/PDF/XC_Series_DVS_Administration_Guide_CLE60UP01.pdf">Cray DVS nodes</a> (Cray XC), or <a href="http://glennklockwood.com/data-intensive/storage/io-forwarding.html#ciod-blue-gene-s-i-o-forwarder">CIOD forwarders</a> (Blue Gene)&lt;/li&gt;&lt;li&gt;<b>Storage Nodes (SN)</b>, which might be Lustre Object Storage Servers (OSSes) or GPFS Network Shared Disk (NSD) servers&lt;/li&gt;&lt;li&gt;<b>The compute fabric</b> (blue lines), which is typically Mellanox InfiniBand, Intel OmniPath, or Cray Aries&lt;/li&gt;&lt;li&gt;<b>The storage fabric</b> (red lines), which is typically Mellanox InfiniBand or Intel OmniPath&lt;/li&gt;&lt;/ul&gt;<br />Given all these parts, there are a bunch of different places you can stick flash devices to create a burst buffer.  For example…<br /><br />&lt;h3&gt;ION-attached Flash&lt;/h3&gt;You can put SSDs inside IO nodes, resulting in an <b>ION-attached flash architecture</b> that looks like this:<br /><br />&lt;div class="separator" style="clear: both; text-align: center;"&gt;<a href="https://2.bp.blogspot.com/-jc5J5bDY5RU/WMWU6URyljI/AAAAAAAAo7k/weeYZm3yRR0VFuD1dOsGnHv8DIEWP1aMQCLcB/s1600/architecture-on-ion.png" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="162" src="https://2.bp.blogspot.com/-jc5J5bDY5RU/WMWU6URyljI/AAAAAAAAo7k/weeYZm3yRR0VFuD1dOsGnHv8DIEWP1aMQCLcB/s320/architecture-on-ion.png" width="320" /></a>&lt;/div&gt;
<br />Gordon, which was the <a href="https://www.slideshare.net/glennklockwood/the-protoburst-buffer-experience-with-the-flashbased-file-system-on-sdscs-gordon">first large-scale deployment of what one could call a burst buffer</a>, had this architecture.  The flash was presented to the compute nodes as block devices using iSCSI, and a compute node could have anywhere between zero and <a href="https://kb.iu.edu/d/bcua">sixteen SSDs</a> mounted to it entirely via software.  More recently, the Tianhe-2 system at NUDT also deployed this architecture and exposes the flash to user applications via <a href="https://link.springer.com/article/10.1007/s11704-014-3499-6">their H<sup>2</sup>FS middleware</a>.<br /><br />&lt;h3&gt;Fabric-attached Flash&lt;/h3&gt;A very similar architecture is to add specific burst buffer nodes on the compute fabric that <i>don’t</i> route I/O, resulting in a <b>fabric-attached flash architecture</b>:<br /><br />&lt;div class="separator" style="clear: both; text-align: center;"&gt;<a href="https://1.bp.blogspot.com/-Q5-lIwe8-UE/WMWZ8xgzkKI/AAAAAAAAo70/9OEOYVKanBY3z8r1nOE1bKbG84d3pu63wCLcB/s1600/architecture-on-edge.png" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="180" src="https://1.bp.blogspot.com/-Q5-lIwe8-UE/WMWZ8xgzkKI/AAAAAAAAo70/9OEOYVKanBY3z8r1nOE1bKbG84d3pu63wCLcB/s320/architecture-on-edge.png" width="320" /></a>&lt;/div&gt;
Like the ION-attached flash design of Gordon, the flash is still embedded within the compute fabric and is logically closer to the compute nodes than the storage nodes.  <a href="https://cug.org/proceedings/cug2016_proceedings/includes/files/pap105-file2.pdf">Cray’s DataWarp solution uses this architecture</a>.<br /><br />Because the flash is still on the compute fabric, this design is very similar to ION-attached flash and the decision to chose it over the ION-attached flash design is mostly non-technical.  It can be more economical to embed flash directly in I/O nodes if those nodes have enough peripheral ports (or physical space!) to support the NICs for the compute fabric, the NICs for the storage fabric, and the flash devices.  However as flash technology moves away from being attached via SAS and towards being directly attached to PCIe, it becomes more difficult to stuff that many high-performance peripherals into a single box without imbalancing something.  As such, it is likely that fabric-attached flash architectures will replace ION-attached flash going forward.<br /><br />Fortunately, any burst buffer software designed for ION-attached flash designs will also probably work on fabric-attached flash designs just fine.  The only difference is that the burst buffer software will no longer have to compete against the I/O routing software for on-node resources like memory or PCIe bandwidth.<br /><br />&lt;h3&gt;CN-attached Flash&lt;/h3&gt;A very different approach to building burst buffers is to attach a flash device to every single compute node in the system, resulting in a <b>CN-attached flash architecture</b>:<br /><br />&lt;div&gt;&lt;div class="separator" style="clear: both; text-align: center;"&gt;<a href="https://2.bp.blogspot.com/-lL1iGUOJOg4/WMWjk_pBKqI/AAAAAAAAo8I/Xd_3yi3-I0Usm_wnMswE8N18ciqMBmvZgCLcB/s1600/architecture-on-cn.png" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="183" src="https://2.bp.blogspot.com/-lL1iGUOJOg4/WMWjk_pBKqI/AAAAAAAAo8I/Xd_3yi3-I0Usm_wnMswE8N18ciqMBmvZgCLcB/s320/architecture-on-cn.png" width="320" /></a>&lt;/div&gt;
<br />This design is neither superior nor inferior to the ION/fabric-attached flash design.  The advantages it has over ION/fabric-attached flash include<br /><br />&lt;ul&gt;&lt;li&gt;<b>Extremely high peak I/O performance</b> -The peak performance scales linearly with the number of compute nodes, so the larger your job, the more performance your job can have.&lt;/li&gt;&lt;li&gt;<b>Very low variation in I/O performance</b> - Because each compute node has direct access to its locally attached SSD, contention on the compute fabric doesn’t affect I/O performance.&lt;/li&gt;&lt;/ul&gt;&lt;div&gt;However, these advantages come at a cost:&lt;/div&gt;</p>
<div><ul><li><b>Limited support for shared-file I/O</b> - &nbsp;Because each compute node doesn't share its SSD with other compute nodes, having many compute nodes write to a single shared file is not a straightforward process. &nbsp;The solution to this issue include from such N-1 style I/O being simply impossible (the default case), relying on <a href="http://computation.llnl.gov/projects/scalable-checkpoint-restart-for-mpi">I/O middleware like the SCR library</a> to manage data distribution, or relying on <a href="http://sc16.supercomputing.org/sc-archive/tech_poster/poster_files/post255s2-file2.pdf">sophisticated I/O services like Intel CPPR</a> to essentially journal all I/O to the node-local flash and flush it to the parallel file system asynchronously.</li><li><b>Data movement outside of jobs becomes difficult</b> - Burst buffers allow users to stage data into the flash <i>before</i> their job starts and stage data back to the parallel file system <i>after</i> their job ends. &nbsp;However in CN-attached flash, this staging will occur while someone else's job might be using the node. &nbsp;This can cause interference, capacity contention, or bandwidth contention. &nbsp;Furthermore, it becomes very difficult to persist data on a burst buffer allocation across multiple jobs without flushing and re-staging it.</li><li><b>Node failures become more problematic</b> - The point of writing out a checkpoint file is to allow you to restart a job in case one of its nodes fails. &nbsp;If your checkpoint file is actually stored on one of the nodes that failed, though, the whole checkpoint gets lost when a node fails. &nbsp;Thus, it becomes critical to flush checkpoint files to the parallel file system as quickly as possible so that your checkpoint file is safe if a node fails. &nbsp;Realistically though, most application failures are not caused by node failures; a study by LLNL found that <a href="http://ieeexplore.ieee.org/document/5645453/">85% of job interrupts do not take out the whole node</a>.</li><li><b>Performance cannot be decoupled from job size</b> - Since you get more SSDs by requesting more compute nodes, there is no way to request only a few nodes and a lot of SSDs. &nbsp;While this is less an issue for extremely large HPC jobs whose I/O volumes typically scale linearly with the number of compute nodes, data-intensive applications often have to read and write large volumes of data but cannot effectively use a huge number of compute nodes.</li></ul><div>If you take a step back and look at what these strengths and weaknesses play to, you might be able to envision what sort of supercomputer design might be best suited for this type of architecture:</div>
</div>
<div><ul><li><b>Relatively low node count</b>, so that you aren't buying way more SSD capacity or performance than you can realistically use given the bandwidth of the parallel file system to which the SSDs must eventually flush</li><li><b>Relatively beefy compute nodes</b>, so that the low node count doesn't hurt you and so that you can tolerate running I/O services to facilitate the asynchronous staging of data and middleware to support shared-file I/O</li><li><b>Relatively beefy network injection bandwidth</b>, so that asynchronous stage in/out doesn't severely impact the MPI performance of the jobs that run before/after yours</li></ul><div>There are also specific application workloads that are better suited to this CN-attached flash design:</div>
<ul><li><b>Relatively large job sizes on average</b>, so that applications routinely use enough compute nodes to get enough I/O bandwidth. &nbsp;Small jobs may be better off using the parallel file system directly, since parallel file systems can usually deliver more I/O bandwidth to smaller compute node counts.</li><li><b>Relatively low diversity of applications</b>, so that any applications that rely on shared-file I/O (which is not well supported by CN-attached flash, as we'll discuss later) can either be converted into using the necessary I/O middleware like SCR, or can be restructured to use only file-per-process or not rely on any strong consistency semantics.</li></ul></div>
<div>And indeed, if you look at the systems that are planning on deploying this type of CN-attached flash burst buffer in the near future, they all fit this mold. &nbsp;In particular, the CORAL Summit and Sierra systems will be deploying these burst buffers at extreme scale, and before them, <a href="https://twitter.com/ProfMatsuoka/status/837438733133754376">Tokyo Tech's Tsubame 3.0</a> will as well. &nbsp;All of these systems derive the majority of their performance from GPUs, leaving the CPUs with the capacity to implement more functionality of their burst buffers in software on the CNs.</div>
<div><br /></div>
<h3>Storage Fabric-attached Flash</h3>
<div>The last notable burst buffer architecture involves attaching the flash on the storage fabric rather than the compute fabric, resulting in SF-attached flash:</div>
<div><br /></div>
<div class="separator" style="clear: both; text-align: center;"><a href="https://3.bp.blogspot.com/-Eu5ZEFFdU4Q/WMWw2M_rJqI/AAAAAAAAo8c/y8twoMUx0h4cGUCTy0LPH9rkonVlW9gMwCLcB/s1600/architecture-backend.png" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="155" src="https://3.bp.blogspot.com/-Eu5ZEFFdU4Q/WMWw2M_rJqI/AAAAAAAAo8c/y8twoMUx0h4cGUCTy0LPH9rkonVlW9gMwCLcB/s320/architecture-backend.png" width="320" /></a></div>
<div><br /></div>
<div>This is not a terribly popular design because</div>
<div><ol><li>it moves the flash far away from the compute node, which is counterproductive to low latency</li><li>it requires that the I/O forwarding layer (the IONs) support enough bandwidth to saturate the burst buffer, which can get expensive</li></ol><div>However, for those HPC systems with custom compute fabrics that are not amenable to adding third-party burst buffers, this may be the only possible architecture. &nbsp;For example, the Argonne Leadership Computing Facility has deployed a <a href="http://files.gpfsug.org/presentations/2016/anl-june/ESS_GPFSUG.pdf">high-performance GPFS file system as a burst buffer</a> alongside their high-capacity GPFS file system in this fashion because it is impractical to integrate flash into their Blue Gene/Q's proprietary compute fabric. &nbsp;Similarly, sites that deploy DDN's Infinite Memory Engine burst buffer solution on systems with proprietary compute fabrics (e.g., Cray Aries on Cray XC) will have to deploy their burst buffer nodes on the storage fabric.</div>
</div>
<div><br /></div>
<h2>Burst Buffer Software</h2>
<div>Ultimately, all of the different burst buffer architectures still amount to sticking a bunch of SSDs into a supercomputing system, and if this was all it took to make a burst buffer though, burst buffers wouldn't be very interesting. &nbsp;Thus, there is another half of the burst buffer ecosystem: the software and middleware that transform a pile of flash into an I/O layer that applications can actually use productively.</div>
<div><br /></div>
<div>In the absolute simplest case, this software layer can just be an XFS file system atop RAIDed SSDs that is presented to user applications as node-local storage. &nbsp;And indeed, this is what SDSC's Gordon system did; for many workloads such as file-per-process I/O, it is a suitable way to get great performance. &nbsp;However, as commercial vendors have gotten into the burst buffer game, they have all started using this software layer to differentiate their burst buffer solutions from their competitors'. &nbsp;This has resulted in modern burst buffers now having a lot of functionality that allow users to do interesting new things with their I/O.</div>
<div><br /></div>
<div>Because this burst buffer differentiation happens entirely in software, it should be no surprise that these burst buffer software solutions look a lot like the software-defined storage products being sold in the enterprise cloud space. &nbsp;The difference is that burst buffer software can be optimized specifically for HPC workloads and technologies, resulting in much nicer and accessible ways in which they can be used by HPC applications.</div>
<div><br /></div>
<h3>Common Software Features</h3>
<div>Before getting too far, it may be helpful to enumerate the features common to many burst buffer software solutions:</div>
<div><ul><li><b>Stage-in and stage-out</b> - Burst buffers are designed to make a job's input data already be available on the burst buffer immediately when the job starts, and to allow the flushing of output data to the parallel file system after the job ends. &nbsp;To make this happen, the burst buffer service must give users a way to indicate what files they want to be available on the burst buffer when they submit their job, and they must also have a way to indicate what files they want to flush back to the file system after the job ends.</li><li><b>Background data movement</b> - Burst buffers are also not designed to be long-term storage, so their reliability can be lower than the underlying parallel file system. &nbsp;As such, users must also have a way to tell the burst buffer to flush intermediate data back to the parallel file system while the job is still running. &nbsp;This should happen using server-to-server copying that doesn't involve the compute node at all.</li><li><b>POSIX I/O API compatibility</b> - The vast majority of HPC applications rely on the POSIX I/O API (open/close/read/write) to perform I/O, and most job scripts rely on tools developed for the POSIX I/O API (cd, ls, cp, mkdir). &nbsp;As such, all burst buffers provide the ability to interact with data through the POSIX I/O API so that they look like regular old file systems to user applications. &nbsp;That said, the POSIX I/O <i>semantics</i> might not be fully supported; as will be described below, you may get an I/O error if you try to perform I/O in a fashion that is not supported by the burst buffer.</li></ul><div>With all this being said, there are still a variety of ways in which these core features can be implemented into a complete burst buffer software solution. &nbsp;Specifically, burst buffers can be accessed through one of several different modes, and each mode provides a different balance of peak performance and usability.</div>
</div>
<div><br /></div>
<h3>Transparent Caching Mode</h3>
<div>The most user-friendly burst buffer mode uses flash to simply act as a giant cache for the parallel file system which I call <b>transparent caching mode</b>. &nbsp;Applications see the burst buffer as a mount point on their compute nodes, and this mount point mirrors the contents of the parallel file system, and any changes I make to one will appear on the other. &nbsp;For example,<br /><br /></div>
<div><pre>$ ls /mnt/lustre/glock<br />bin  project1  project2  public_html  src<br /><br />### Burst buffer mount point contains the same stuff as Lustre<br />$ ls /mnt/burstbuffer/glock<br />bin  project1  project2  public_html  src<br /><br />### Create a file on Lustre...<br />$ touch /mnt/lustre/glock/hello.txt<br /><br />$ ls /mnt/lustre/glock<br />bin  hello.txt  project1  project2  public_html  src<br /><br />### ...and it automatically appears on the burst buffer.<br />$ ls /mnt/burstbuffer/glock<br />bin  hello.txt  project1  project2  public_html  src<br /><br />### However its contents are probably not on the burst buffer's flash<br />### yet since we haven't read its contents through the burst buffer<br />### mount point, which is what would cause it to be cached<br /></pre><div><br />However, if I access a file through the burst buffer mount (<code>/mnt/burstbuffer/glock</code>) rather than the parallel file system mount (<code>/mnt/lustre/glock</code>),<br /><ol><li>if hello.txt is already cached on the burst buffer's SSDs, it will be read directly from flash</li><li>if hello.txt is not already cached on the SSDs, the burst buffer will read it from the parallel file system, cache its contents on the SSDs, and return its contents to me</li></ol><div>Similarly, if I write to hello.txt via the burst buffer mount, my data will be cached to the SSDs and <i>will not</i> immediately appear on the parallel file system. &nbsp;It will eventually flush out to the parallel file system, or I could tell the burst buffer service to explicitly flush it myself.</div>
<div><br /></div>
<div>This transparent caching mode is by far the easiest, since it looks exactly like the parallel file system for all intents and purposes. &nbsp;However if you know that your application will never read any data more than once, it's far less useful in this fully transparent mode. &nbsp;As such, burst buffers that implement this mode provide proprietary APIs that allow you to stage-in data, control the caching heuristics, and explicitly flush data from the flash to the parallel file system. &nbsp;</div>
<div><br /></div>
<div>DDN's Infinite Memory Engine and Cray's DataWarp both implement this transparent caching mode, and, in principle, it can be implemented on any of the burst buffer architectures outlined above.</div>
</div>
<div><br /></div>
<div><h3>Private PFS Mode</h3>Although the transparent caching mode is the easiest to use, it doesn't give users a lot of control over what data does or doesn't need to be staged into the burst buffer. &nbsp;Another access mode involves creating a private parallel file system on-demand for jobs, which I will call <b>private PFS mode</b>. &nbsp;It provides a new parallel file system that is only mounted on your job's compute nodes, and this mount point contains only the data you explicitly copy to it:</div>
<div><br /><pre>### Burst buffer mount point is empty; we haven't put anything there,<br />### and this file system is private to my job<br />$ ls /mnt/burstbuffer<br /><br />### Create a file on the burst buffer file system...<br />$ dd if=/dev/urandom of=/mnt/burstbuffer/mydata.bin bs=1M count=10<br />10+0 records in<br />10+0 records out<br />10485760 bytes (10 MB) copied, 0.776115 s, 13.5 MB/s<br /><br />### ...it appears on the burst buffer file system...<br />$ ls -l /mnt/burstbuffer<br />-rw-r----- 1 glock glock 10485760 Jan  1 00:00 mydata.bin<br /><br />### ...and Lustre remains entirely unaffected<br />$ ls /mnt/lustre/glock<br />bin  project1  project2  public_html  src</pre><br /></div>
This is a little more complicated than transparent caching mode because you must now manage two file system namespaces: the parallel file system and your private burst buffer file system. &nbsp;However this gives you the option to target your I/O to one or the other, so that a tiny input deck can stay on Lustre while your checkpoints are written out to the burst buffer file system.<br /><br />In addition, the burst buffer private file system is strongly consistent; as soon as you write data out to it, you can read that data back from any other node in your compute job. &nbsp;While this is true of transparent caching mode <i>if you always access your data through the burst buffer mount point</i>, you can run into trouble if you accidentally try to read a file from the original parallel file system mount point after writing out to the burst buffer mount. &nbsp;Since private PFS mode provides a completely different file system and namespace, it's a bit harder to make this mistake.<br /><br />Cray's DataWarp implements private PFS mode, and the <a href="https://twitter.com/ProfMatsuoka/status/837440717836414976">Tsubame 3.0 burst buffer will be implementing private PFS mode using on-demand BeeGFS</a>. &nbsp;This mode is most easily implemented on fabric/ION-attached flash architectures, but Tsubame 3.0 is demonstrating that it can also be done on CN-attached flash.<br /><br /><h3>Log-structured/Journaling Mode</h3>As probably the least user-friendly but highest-performing use mode, <b>log-structured (or journaling) mode</b> burst buffers present themselves to users like a file system, but they do not support the full extent of file system features. &nbsp;Under the hood, writes are saved to the flash not as files, but as records that contain a timestamp, the data to be written, and the location in the file to which the data should be written. &nbsp;These logs are continually appended as the application performs its writes, and when it comes time to flush the data to the parallel file system, the logs are replayed to effectively reconstruct the file that the application was trying to write.<br /><br />This can perform extremely well since even random I/O winds up being restructured as sequentially appended I/O. &nbsp;Furthermore, there can be as many logs as there are writers; this allows writes to happen with zero lock contention, since contended writes are resolved out when the data is re-played and flushed.<br /><br />Unfortunately, log-structured writes make reading very difficult, since the read can no longer seek directly to a file offset to find the data it needs. &nbsp;Instead, the log needs to be replayed to some degree, effectively forcing a flush to occur. &nbsp;Furthermore, if the logs are spread out across different logical flash domains (as would happen in CN-attached flash architectures), read-back may require the logs to be centrally collected before the replay can happen, or it may require inter-node communication to coordinate who owns the different bytes that the application needs to read.<br /><br />What this amounts to is functionality that may present itself like a private parallel file system burst buffer, but behaves very differently on reads and writes. &nbsp;For example, attempting to read the data that exists in a log that doesn't belong to the writer might generate an I/O error, so applications (or I/O middleware) probably need to have very well-behaved I/O to get the full performance benefits of this mode. &nbsp;Most extreme-scale HPC applications already do this, so log-structured/journaling mode is a very attractive approach for very large applications that rely on extreme write performance to checkpoint their progress.<br /><br />Log-structured/journaling mode is well suited for CN-attached flash since logs do not need to live on a file system that presents a single shared namespace across all compute nodes. &nbsp;In practice, the IBM CORAL systems will probably provide log-structured/journaling mode through IBM's burst buffer software. &nbsp;Oak Ridge National Laboratory has also demonstrated <a href="http://ieeexplore.ieee.org/document/7004215/">a log-structured burst buffer system called BurstMem</a> on a fabric-attached flash architecture. &nbsp;Intel's CPPR library, to be deployed with the Argonne Aurora system, <a href="file://C:/Users/Glenn/Downloads/MS19_CORAL_NRE_CPPR_HLD_v1.1_Final.pdf">may also implement this functionality</a>&nbsp;atop the 3D XPoint to be embedded in each compute node.<br /><br /><h3>Other Modes </h3>The above three modes are not the only ones that burst buffers may implement, and some burst buffers support more than one of the above modes. &nbsp;For example, Cray's DataWarp, in addition to supporting private PFS and transparent caching modes, also has a swap mode that allows compute nodes to use the flash as swap space to prevent hard failures for data analysis applications that consume non-deterministic amounts of memory. &nbsp;In addition, <a href="file://C:/Users/Glenn/Downloads/MS18_CORAL_NRE_CPPR_ScopeStatement_V1.1_final%20(3).pdf">Intel's CPPR library is targeting byte-addressable nonvolatile memory</a> which would expose a load/store interface, rather than the typical POSIX open/write/read/close interface, to applications.<br /><br /><h2>Outlook</h2></div>
<p>&lt;/div&gt;</p>
<div>Burst buffers, practically speaking, remain in their infancy, and there is a lot of room for the landscape I've outlined here to change. &nbsp;For example, the common software features I highlighted (staging, background data movement, and POSIX API support) are still largely implemented via proprietary, non-standard APIs at present. &nbsp;There is effort to get burst buffer vendors to agree to a common API, and as this process proceeds, features may appear or disappear as customers define what is and isn't a worthwhile differentiating feature.</div>
<div><br /></div>
<div>On the hardware front, the burst buffer ecosystem is also in flux. &nbsp;ION-attached flash is where burst buffers began, but as discussed above, they are likely to be replaced by dedicated fabric-attached flash servers. &nbsp;In addition, the emergence of storage-class memory (that is, byte-addressable nonvolatile memory) will also add a new dimension to burst buffers that may make one architecture the clear winner over the others. &nbsp;At present though, both fabric-attached and CN-attached burst buffers have their strengths and weaknesses, and neither is at risk of disappearing in the next five years.</div>
<div><br /></div>
<div>As more extreme-scale systems begin to hit the floor and users figure out what does and doesn't work across the diversity of burst buffer hardware and software features, the picture is certain to become clearer. &nbsp;Once that happens, I'll be sure to post another update.</div>

</div>
<div class="tags-container">
	
</div>
<style>
#uppy {
  position: fixed;
  bottom: 50px;
  right: 50px;
  z-index: 99;
  border: none;
  outline: none;
  background-color: darkturquoise;
  color: black;
  cursor: pointer;
  margin:15px;
  border-radius: 10px;
  width: 100px;
  height: 20px;
}

#returnTop:hover {
  background-color: #555;
}
</style>

<button id="uppy" title="Return to Top" class="btn btn-lg">Back to top</button>

<script>
(function() {

var scrollTop = function() {
    window.scrollTo(0, 0);
};

document.getElementById('uppy').onclick = scrollTop;

})();
</script>


<div class="navigation">
	
		<a class="prev" href="/personal-blog/2017/beyond-single-core-r-parallel-data-analysis/">< Beyond Single Core R- Parallel Data Analysis</a>
	 
	<a class="next" href="/personal-blog/2017/should-i-use-chapel-or-julia-for-my-next-project/">Should I use Chapel or Julia for my next project? ></a>

</div>

	<div class="footer">
		<span style="padding-right:10px"><font color="red">©️ </font><a href="https://hpc.social"><b>hpc.social</b> community</a></span> 
		| <a style="padding-left:10px; padding-right:10px" href="/personal-blog/archive/">Archive</a>
		| <a style="padding-left:10px; padding-right:10px" href="/personal-blog/">Posts</a>
		| <a style="padding-left:10px; padding-right:10px" href="/personal-blog/about/">About</a>
		| <a style="padding-left:10px; padding-right:10px" href="https://hpc.social/blog">hpc.social blogs</a>
		| <a style="padding-left:37%;" target="_blank" href="https://github.com/hpc-social/personal-blog">Add Your Blog</a>
	</div>
</div>
    <script src="/personal-blog/assets/scripts.js"></script>
    <script type="text/javascript">
        if (localStorage.theme === 'light') {
            document.documentElement.setAttribute('data-theme', 'light');
            document.getElementById('mode-switcher').classList.add('active');
        } else if (localStorage.theme === 'dark' || localStorage.theme === '' || (!('theme' in localStorage))) {
            document.documentElement.setAttribute('data-theme', 'dark');
            document.getElementById('mode-switcher').classList.add('active');
        }
    </script>
</body>
</html>

